---
layout: post
title: "Reliable RabbitMQ: Preventing Message Loss, Duplicates, and Ordering Issues"
subtitle: "Building a Reliable Messaging System"
date: 2025-10-31
tags: [architecture, rabbitmq, reliability, messaging]
timezone: Europe/Madrid
background: "/img/posts/01.jpg"
---

<blockquote>
  <p>“Duplicate messages aren’t a bug, they’re the price of reliability.”</p>
</blockquote>

<hr />

<h2>Introduction</h2>
<p>In distributed systems, “never lose a message” sounds simple, until you try to guarantee it.
Networks fail, consumers crash, brokers restart, and suddenly you’re facing duplicated or lost events.</p>
<p>In this article, we’ll explore how to build <strong>a reliable, idempotent, and ordered message pipeline</strong> using <strong>RabbitMQ</strong>.
We’ll go through real-world failure scenarios and the patterns that keep your system consistent, even under chaos.</p>

<hr />

<h2>1. Understanding the Message Lifecycle</h2>
<p>A message travels across three stages:</p>
<ol>
  <li><strong>Producer → Broker</strong> (publishing)</li>
  <li><strong>Broker → Consumer</strong> (delivery)</li>
  <li><strong>Consumer → Database / Side-effect</strong> (processing)</li>
</ol>
<p>Each stage can fail independently. Let’s see how to protect all of them.</p>

<hr />

<h2>2. Producer Safety, The Outbox Pattern</h2>
<p>Publishing a message outside of your main transaction is dangerous:</p>
<ul>
  <li>The transaction could be committed, but the message never gets sent.</li>
  <li>Or the message is sent, but the transaction rollback.</li>
</ul>
<p>To solve this, we use the <strong>Outbox Pattern</strong>: store outgoing messages <strong>in your database</strong>, within the same transaction that triggers them.</p>

<pre><code class="language-ruby"># app/services/orders/create_order.rb
class CreateOrder
  def call(order_params)
    ActiveRecord::Base.transaction do
      order = Order.create!(order_params)

      OutboxEvent.create!(
        event_type: "OrderCreated",
        payload: { id: order.id, total: order.total }
      )
    end
  end
end</code></pre>

<p>Then, a background job (dispatcher) safely publishes these events to RabbitMQ with publisher confirms:</p>

<pre><code class="language-ruby"># app/jobs/outbox_dispatcher.rb
class OutboxDispatcher
  def call
    connection = Bunny.new.start
    channel = connection.create_channel
    exchange = channel.direct('events', durable: true)

    OutboxEvent.pending.find_each do |event|
      channel.confirm_select
      exchange.publish(event.payload.to_json,
                       routing_key: event.event_type,
                       persistent: true)

      channel.wait_for_confirms
      event.mark_as_sent!
    end
  ensure
    connection.close
  end
end</code></pre>

<p>NOTE: Another popular alternative is to use tools like <a href="https://debezium.io/" target="_blank" rel="noopener">Debezium</a> to send the messages from the outbox table to RabbitMq.</p>
<p><strong>Guarantees:</strong></p>
<ul>
  <li>No messages are lost between your app and RabbitMQ.</li>
  <li>Everything is transactional and recoverable.</li>
</ul>

<hr />

<h2>3. Broker Safety, Durability and Persistence</h2>
<p>RabbitMQ won’t magically persist everything, you need to configure it properly.</p>
<p>Make sure:</p>
<ul>
  <li>The queue is durable</li>
  <li>The message is persistent</li>
</ul>

<pre><code class="language-ruby">channel.queue('orders', durable: true)

exchange.publish(payload.to_json, persistent: true)</code></pre>

<p><strong>Guarantees:</strong></p>
<ul>
  <li>Messages survive broker restarts.</li>
  <li>No loss even if RabbitMQ crashes mid-flight.</li>
</ul>

<hr />

<h2>4. Consumer Safety, Acks and Idempotency</h2>
<p>Once RabbitMQ delivers a message, it expects an acknowledgement (ack). If the consumer crashes before sending the ack, RabbitMQ re-delivers the message.</p>
<p>That means:</p>
<ul>
  <li>RabbitMQ guarantees at-least-once delivery, not exactly-once.</li>
</ul>
<p>So you must design your consumers to be idempotent, able to process the same message multiple times without side effects.</p>

<p>Example: Idempotent Consumer in Ruby</p>

<pre><code class="language-ruby">class OrderCreatedConsumer
  def call(delivery_info, properties, body)
    payload = JSON.parse(body)
    message_id = properties.message_id

    return if ProcessedMessage.exists?(message_id: message_id) # Idempotency check

    ActiveRecord::Base.transaction do
      ProcessedMessage.create!(message_id: message_id)
      OrderProcessor.new.call(payload)
    end

    channel.ack(delivery_info.delivery_tag)
  rescue => e
    channel.reject(delivery_info.delivery_tag, requeue: true)
  end
end</code></pre>

<p>NOTE: Another valid approach is to use a create_or_update operation based on a unique key in the payload.
The key idea is that processing the same message twice must produce the same result, without creating duplicates or inconsistent state.</p>
<p><strong>Guarantees:</strong></p>
<ul>
  <li>Duplicates are harmless.</li>
</ul>
<p>Messages should be acknowledged only after the database transaction commits successfully.
This ensures that if the consumer crashes during processing, RabbitMQ will re-deliver the message, and thanks to idempotency checks, re-processing it will not cause duplicate effects.</p>

<hr />

<h2>5. Message Ordering: Beyond "One Consumer per Queue"</h2>
<p>RabbitMQ guarantees FIFO only within a single queue and a single consumer.</p>
<p>Let’s look at a real example:</p>

<pre><code>Use case 1 → publishes message M1
Subscriber → runs use case 2 → publishes message M2
Subscriber → runs use case 3 → publishes message M3</code></pre>

<p>Now imagine a single queue with multiple consumers:</p>
<p>M1, M2, and M3 are enqueued in order.</p>
<p>RabbitMQ distributes them round-robin across consumers.</p>
<p>If Consumer 1 is slower than Consumer 2, M3 may finish before M1.</p>
<p>The observable order of effects breaks, generating bugs.</p>
<p>This happens because ordering guarantees stop once messages are processed concurrently, even if RabbitMQ delivered them in order.</p>

<h3>How to Fix It</h3>

<h4>Option 1: One Consumer per Queue (Strict FIFO)</h4>
<p>The simplest solution: one queue + one consumer. For the next reasons:</p>
<ul>
  <li>RabbitMQ delivers messages in order.</li>
  <li>Your consumer processes sequentially.</li>
  <li>Each message is acked only after successful processing.</li>
</ul>
<p>You can also limit concurrency explicitly:</p>

<pre><code class="language-ruby">channel.prefetch(1)</code></pre>

<p>This ensures only one unacknowledged message is in flight per consumer.</p>

<p>If you can allow one consumer per queue, you won't have order problems.</p>

<h4>Option 2: One Queue per Side-Effect (Parallel + Safe)</h4>
<p>If you need parallelism and each queue represents an independent side-effect, you can create one queue per workflow. Each message in a queue triggers a specific side-effect.</p>

<pre><code>exchange (direct)
├── queue_use_case_1 → consumer_use_case_1
├── queue_use_case_2 → consumer_use_case_2
└── queue_use_case_3 → consumer_use_case_3</code></pre>

<p>Each queue represents a specific side-effect. 
Messages are routed to the queue corresponding to the side-effect they trigger. 
Multiple consumers can process messages in parallel within the same queue without breaking the process logic, 
because each message is an independent side-effect.</p>

<p>Note: Setting <code>prefetch = 1</code> limits concurrency per consumer but does not guarantee strict ordering. 
In this model, strict ordering is not required because each message represents an independent side-effect.</p>

<p>Example:</p>
<pre><code>Queue receives messages: M1a, M1b, M1c
Consumer A processes M1a → publishes M2a
Consumer B processes M1b → publishes M2b
Consumer A processes M1c → publishes M2c
</code></pre>

<p>Even if M2a is published after M2b and M2c, the system works correctly because each message represents an independent side-effect. 
The logical flow of the process is preserved, regardless of the order in which messages are processed within a queue.</p>

<p>This approach is very good option if you need one or multiple consumers per queue. It's pretty scalable, you can monitorize each queue independently and adjust resources as needed.</p>
<p>In my experience, this model works well for a variety of use cases, especially when dealing with complex workflows that require high availability and fault tolerance.</p>

<hr />

<h2>6. Network Failures, The Real Enemy</h2>

<h3>Common scenarios</h3>
<table>
  <thead>
    <tr>
      <th>Scenario</th>
      <th>What happens</th>
      <th>Risk</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Consumer processes message, loses connection before ack</td>
      <td>RabbitMQ re-delivers</td>
      <td>Duplicate</td>
    </tr>
    <tr>
      <td>Consumer receives message but crashes before ack</td>
      <td>RabbitMQ re-delivers</td>
      <td>Duplicate</td>
    </tr>
    <tr>
      <td>Producer publishes but loses connection before confirm</td>
      <td>Message may or may not have arrived</td>
      <td>Retry needed</td>
    </tr>
  </tbody>
</table>

<br />

<h3>How to survive</h3>
<p>Some strategies:</p>
<ul>
  <li>Publisher confirms: ensures the producer knows whether the message reached the broker.</li>
  <li>Manual acks on consumers: prevents marking a message as processed before it has actually been completed.</li>
  <li>Retries and DLQs: handle errors without losing messages.</li>
  <li>Idempotency: key to safely processing duplicate messages without side effects.</li>
</ul>
<p><strong>Guarantees:</strong></p>
<ul>
  <li>No lost messages even under network instability.</li>
  <li>Only duplicates, which are safely ignored.</li>
</ul>

<hr />

<h2>7. Putting It All Together</h2>

<h3>Common Risks and Solutions</h3>
<table>
  <thead>
    <tr>
      <th>Risk</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Lost messages on publish</td>
      <td>Outbox Pattern + Publisher Confirms</td>
    </tr>
    <tr>
      <td>Lost messages in RabbitMQ</td>
      <td>Durable Queues + Persistent Messages</td>
    </tr>
    <tr>
      <td>Lost messages on consume</td>
      <td>manual Ack after commit</td>
    </tr>
    <tr>
      <td>Duplicates</td>
      <td>Idempotency</td>
    </tr>
    <tr>
      <td>Out-of-order processing</td>
      <td>One consumer per queue or queue per side-effect</td>
    </tr>
    <tr>
      <td>Network failures</td>
      <td>Retries + DLQ + Confirm mode</td>
    </tr>
  </tbody>
</table>

<hr />

<h2>8. The Reality of Distributed Systems</h2>
<p>You can’t have exactly-once semantics in an unreliable network.
What you can have is at-least-once delivery with idempotent consumers,
and that’s good for real-world systems.</p>
<p>By combining:</p>
<ul>
  <li>Outbox pattern</li>
  <li>Durable queues</li>
  <li>Persistent messages</li>
  <li>Manual acks</li>
  <li>Idempotency</li>
  <li>Proper ordering strategies</li>
</ul>
<p>you achieve no message loss and predictable, consistent behavior, even under failure.</p>

<hr />

<h2>Final Thoughts</h2>
<p>Building reliable message-driven systems isn’t about eliminating failure, it’s about making failure safe.
With RabbitMQ, that means embracing duplicates, ensuring order where it matters, and designing every step to survive a crash, a retry, or a network glitch.</p>
<p><strong>Reliability isn’t magic, it’s discipline.</strong></p>